#!/usr/bin/env python3
# E Minor v1.0 â€” Star-Code Validator and Compiler
# Performs AOT validations on the AST produced by eminor_parser.py
# and compiles valid E Minor programs

import sys, json, os, argparse, re, struct, tempfile, subprocess
from typing import List, Dict, Any, Optional, Tuple, Set, Union
from enum import Enum, auto
from dataclasses import dataclass, field

def _walk(node, fn):
    if isinstance(node, dict):
        fn(node)
        for k, v in node.items():
            if isinstance(v, (dict, list)):
                _walk(v, fn)
    elif isinstance(node, list):
        for x in node: _walk(x, fn)

SEVERITY = {"ERROR":"ERROR","WARN":"WARN","INFO":"INFO"}

def validate(ast: Dict[str, Any]) -> List[Dict[str, Any]]:
    issues: List[Dict[str, Any]] = []
    declared_caps = set()   # from LetDecl
    inited_caps   = set()   # after InitStmt
    leased_caps   = set()   # after Lease/Sublease/Release
    labels        = set()   # defined labels
    gotos         = []      # (label, line, col)

    # First pass: collect labels and lets
    def pass1(n):
        if n.get("_type") == "LetDecl":
            name = n["name"]["name"]
            declared_caps.add(name)
        elif n.get("_type") == "LabelStmt":
            labels.add(n["name"])

    _walk(ast, pass1)

    def report(kind, msg, line, col, code):
        issues.append({"severity":kind,"code":code,"message":msg,"line":line,"column":col})

    # Second pass: validations
    def pass2(n):
        t = n.get("_type")
        if t == "InitStmt":
            name = n["target"]["name"]
            inited_caps.add(name)
        elif t in ("LoadStmt","RenderStmt","InputStmt","OutputStmt","StampStmt","ExpireStmt"):
            name = n["target"]["name"]
            if name not in inited_caps and name not in declared_caps:
                report(SEVERITY["WARN"], f"Capsule ${name} used before init/let", n["line"], n["column"], "SC001")
        elif t in ("SendStmt","RecvStmt"):
            a = n["chan"]["name"]; b = n["pkt"]["name"]
            if a not in inited_caps and a not in declared_caps:
                report(SEVERITY["WARN"], f"Channel ${a} used before init/let", n["line"], n["column"], "SC002")
            if b not in inited_caps and b not in declared_caps:
                report(SEVERITY["WARN"], f"Packet ${b} used before init/let", n["line"], n["column"], "SC003")
        elif t == "LeaseStmt":
            nm = n["target"]["name"]
            if nm in leased_caps:
                report(SEVERITY["ERROR"], f"Capsule ${nm} double-lease without release", n["line"], n["column"], "SC010")
            leased_caps.add(nm)
        elif t in ("SubleaseStmt",):
            nm = n["target"]["name"]
            if nm not in leased_caps:
                report(SEVERITY["WARN"], f"Sublease on non-leased capsule ${nm}", n["line"], n["column"], "SC011")
        elif t == "ReleaseStmt":
            nm = n["target"]["name"]
            if nm not in leased_caps:
                report(SEVERITY["WARN"], f"Release on non-leased capsule ${nm}", n["line"], n["column"], "SC012")
            leased_caps.discard(nm)
        elif t == "SleepStmt":
            # duration must be integer nanoseconds
            dur = n["duration"]["value"]
            if not isinstance(dur, int) or dur < 0:
                report(SEVERITY["ERROR"], "Sleep duration must be non-negative integer nanoseconds", n["line"], n["column"], "SC020")
        elif t == "ExpireStmt":
            dur = n["duration"]["value"]
            if not isinstance(dur, int) or dur < 0:
                report(SEVERITY["ERROR"], "Expire duration must be non-negative integer nanoseconds", n["line"], n["column"], "SC021")
        elif t == "GotoStmt":
            gotos.append((n["label"], n["line"], n["column"]))
        elif t == "IfStmt":
            # shallow type-ish check: cond should be literal bool or an expression (assume ok); warn if literal non-bool
            c = n["cond"]
            if c.get("_type") == "Literal" and c.get("kind") != "BOOL":
                report(SEVERITY["WARN"], "Non-boolean literal used as condition", n["line"], n["column"], "SC030")

    _walk(ast, pass2)

    # Post: check gotos
    for label, line, col in gotos:
        if label not in labels:
            report(SEVERITY["ERROR"], f"goto :{label} targets undefined label", line, col, "SC040")

    return issues

def main():
    import argparse
    ap = argparse.ArgumentParser(description="E Minor Star-Code Validator")
    ap.add_argument("ast_json", help="Path to AST JSON file generated by eminor_parser.py")
    args = ap.parse_args()
    with open(args.ast_json, "r", encoding="utf-8") as f:
        ast = json.load(f)
    issues = validate(ast)
    print(json.dumps({"issues": issues}, indent=2))

# ========================= E Minor Compiler =========================
# The following code extends the validator to create a complete compiler

# ---- Language definition constants ----
KEYWORDS = {
    'initialize', 'capsule', 'assign', 'value', 'to', 'invoke', 'function', 'with',
    'terminate', 'execution', 'if', 'else', 'loop', 'goto', 'let', 'worker',
    'u8', 'u16', 'u32', 'u64', 'i8', 'i16', 'i32', 'i64', 'f32', 'f64',
    'bool', 'stamp', 'duration', 'byte', 'true', 'false', 'main', 'entry_point',
    'module', 'export', 'import', 'ns', 'ms', 's', 'm', 'h'
}

# Time unit conversions to nanoseconds
TIME_UNITS = {
    'ns': 1,
    'ms': 1_000_000,
    's': 1_000_000_000,
    'm': 60 * 1_000_000_000,
    'h': 60 * 60 * 1_000_000_000
}

# Opcodes for IR generation
OPCODES = {
    "NOP": 0x00,
    "INIT": 0x01,
    "LOAD": 0x02,
    "CALL": 0x03,
    "CALLA": 0x04,
    "EXIT": 0x05,
    
    "LEASE": 0x10,
    "SUBLEASE": 0x11,
    "RELEASE": 0x12,
    "CHECKEXP": 0x13,
    
    "RENDER": 0x20,
    "INPUT": 0x21,
    "OUTPUT": 0x22,
    
    "SEND": 0x30,
    "RECV": 0x31,
    
    "SPAWN": 0x40,
    "JOIN": 0x41,
    
    "STAMP": 0x50,
    "EXPIRE": 0x51,
    "SLEEP": 0x52,
    "YIELD": 0x53,
    
    "ERROR": 0x60,
    
    "PUSHK": 0x80,
    "PUSHCAP": 0x82,
    "UNOP": 0x90,
    "BINOP": 0x91,
    
    "JZ": 0xA0,
    "JNZ": 0xA1,
    "JMP": 0xA2,
    
    "END": 0xFF
}

# Binary operators and their codes
BINARY_OPS = {
    "||": 1, 
    "&&": 2,
    "==": 3, 
    "!=": 4,
    "<": 5, 
    ">": 6, 
    "<=": 7, 
    ">=": 8,
    "+": 9, 
    "-": 10, 
    "*": 11, 
    "/": 12, 
    "%": 13
}

# Unary operators and their codes
UNARY_OPS = {
    "!": 1, 
    "~": 2, 
    "u-": 3
}

class TokenType(Enum):
    # Keywords
    KW_INITIALIZE = auto()
    KW_CAPSULE = auto()
    KW_ASSIGN = auto()
    KW_VALUE = auto()
    KW_TO = auto()
    KW_INVOKE = auto()
    KW_FUNCTION = auto()
    KW_WITH = auto()
    KW_TERMINATE = auto()
    KW_EXECUTION = auto()
    KW_IF = auto()
    KW_ELSE = auto()
    KW_LOOP = auto()
    KW_GOTO = auto()
    KW_LET = auto()
    KW_WORKER = auto()
    KW_BYTE = auto()
    KW_TRUE = auto()
    KW_FALSE = auto()
    KW_MAIN = auto()
    KW_ENTRY_POINT = auto()
    KW_MODULE = auto()
    KW_EXPORT = auto()
    KW_IMPORT = auto()
    
    # Type names
    KW_U8 = auto()
    KW_U16 = auto()
    KW_U32 = auto()
    KW_U64 = auto()
    KW_I8 = auto()
    KW_I16 = auto()
    KW_I32 = auto()
    KW_I64 = auto()
    KW_F32 = auto()
    KW_F64 = auto()
    KW_BOOL = auto()
    KW_STAMP = auto()
    KW_DURATION = auto()
    
    # Time units
    KW_NS = auto()
    KW_MS = auto()
    KW_S = auto()
    KW_M = auto()
    KW_H = auto()
    
    # Directives
    AT_MAIN = auto()
    AT_ENTRY_POINT = auto()
    AT_MODULE = auto()
    AT_EXPORT = auto()
    AT_IMPORT = auto()
    
    # Hash directives
    HASH_INIT = auto()
    HASH_LOAD = auto()
    HASH_CALL = auto()
    HASH_EXIT = auto()
    HASH_LEASE = auto()
    HASH_SUBLEASE = auto()
    HASH_RELEASE = auto()
    HASH_CHECK_EXP = auto()
    HASH_RENDER = auto()
    HASH_INPUT = auto()
    HASH_OUTPUT = auto()
    HASH_SEND = auto()
    HASH_RECV = auto()
    HASH_SPAWN = auto()
    HASH_JOIN = auto()
    HASH_STAMP = auto()
    HASH_EXPIRE = auto()
    HASH_SLEEP = auto()
    HASH_YIELD = auto()
    HASH_ERROR = auto()
    HASH_IF = auto()
    HASH_ELSE = auto()
    HASH_ENDIF = auto()
    HASH_LOOP = auto()
    HASH_BREAK = auto()
    HASH_CONTINUE = auto()
    
    # Literals
    INT = auto()
    HEX = auto()
    FLOAT = auto()
    DURATION = auto()
    STRING = auto()
    BOOL = auto()
    
    # Identifiers
    IDENT = auto()
    DOLLAR_IDENT = auto()
    
    # Operators
    PLUS = auto()
    MINUS = auto()
    STAR = auto()
    SLASH = auto()
    PERCENT = auto()
    BANG = auto()
    TILDE = auto()
    EQ = auto()
    EQEQ = auto()
    BANGEQ = auto()
    LT = auto()
    GT = auto()
    LTE = auto()
    GTE = auto()
    ANDAND = auto()
    OROR = auto()
    AMP = auto()
    BAR = auto()
    CARET = auto()
    
    # Punctuation
    LPAREN = auto()
    RPAREN = auto()
    LBRACE = auto()
    RBRACE = auto()
    LBRACKET = auto()
    RBRACKET = auto()
    COMMA = auto()
    SEMICOLON = auto()
    COLON = auto()
    DOT = auto()
    HASH = auto()
    AT = auto()
    
    # Special
    EOF = auto()
    ERROR = auto()

class Token:
    def __init__(self, type: TokenType, lexeme: str, line: int, column: int, value=None):
        self.type = type
        self.lexeme = lexeme
        self.line = line
        self.column = column
        self.value = value
    
    def __repr__(self):
        if self.value is None:
            return f"{self.type.name}({self.lexeme}) at {self.line}:{self.column}"
        return f"{self.type.name}({self.lexeme}:{self.value}) at {self.line}:{self.column}"

class LexerError(Exception):
    pass

class Lexer:
    def __init__(self, source: str):
        self.source = source
        self.pos = 0
        self.line = 1
        self.column = 1
        self.current_char = self.source[0] if source else None
        
        # Build keyword and directive maps
        self.keywords = {}
        for kw in KEYWORDS:
            self.keywords[kw] = getattr(TokenType, f"KW_{kw.upper()}", TokenType.IDENT)
        
        # Hash directives
        self.hash_directives = {
            "init": TokenType.HASH_INIT,
            "load": TokenType.HASH_LOAD,
            "call": TokenType.HASH_CALL,
            "exit": TokenType.HASH_EXIT,
            "lease": TokenType.HASH_LEASE,
            "sublease": TokenType.HASH_SUBLEASE,
            "release": TokenType.HASH_RELEASE,
            "check_exp": TokenType.HASH_CHECK_EXP,
            "render": TokenType.HASH_RENDER,
            "input": TokenType.HASH_INPUT,
            "output": TokenType.HASH_OUTPUT,
            "send": TokenType.HASH_SEND,
            "recv": TokenType.HASH_RECV,
            "spawn": TokenType.HASH_SPAWN,
            "join": TokenType.HASH_JOIN,
            "stamp": TokenType.HASH_STAMP,
            "expire": TokenType.HASH_EXPIRE,
            "sleep": TokenType.HASH_SLEEP,
            "yield": TokenType.HASH_YIELD,
            "error": TokenType.HASH_ERROR,
            "if": TokenType.HASH_IF,
            "else": TokenType.HASH_ELSE,
            "endif": TokenType.HASH_ENDIF,
            "loop": TokenType.HASH_LOOP,
            "break": TokenType.HASH_BREAK,
            "continue": TokenType.HASH_CONTINUE
        }
        
        # At directives
        self.at_directives = {
            "main": TokenType.AT_MAIN,
            "entry_point": TokenType.AT_ENTRY_POINT,
            "module": TokenType.AT_MODULE,
            "export": TokenType.AT_EXPORT,
            "import": TokenType.AT_IMPORT
        }
    
    def advance(self):
        if self.current_char == '\n':
            self.line += 1
            self.column = 1
        else:
            self.column += 1
            
        self.pos += 1
        if self.pos >= len(self.source):
            self.current_char = None
        else:
            self.current_char = self.source[self.pos]
    
    def skip_whitespace(self):
        while self.current_char and self.current_char.isspace():
            self.advance()
    
    def skip_comment(self):
        if self.current_char == '/' and self.peek() == '/':
            self.advance()  # Skip first /
            self.advance()  # Skip second /
            
            # Skip until end of line
            while self.current_char and self.current_char != '\n':
                self.advance()
            
            # Skip newline character
            if self.current_char:
                self.advance()
        elif self.current_char == '/' and self.peek() == '*':
            self.advance()  # Skip /
            self.advance()  # Skip *
            
            # Skip until end of block comment
            while self.current_char:
                if self.current_char == '*' and self.peek() == '/':
                    self.advance()  # Skip *
                    self.advance()  # Skip /
                    break
                self.advance()
    
    def peek(self, offset=1):
        peek_pos = self.pos + offset
        if peek_pos >= len(self.source):
            return None
        return self.source[peek_pos]
    
    def tokenize(self):
        tokens = []
        
        # Initialize current character
        if not self.source:
            return tokens
        
        while self.current_char:
            # Skip whitespace and comments
            if self.current_char.isspace():
                self.skip_whitespace()
                continue
                
            if self.current_char == '/' and (self.peek() == '/' or self.peek() == '*'):
                self.skip_comment()
                continue
                
            # Handle identifiers and keywords
            if self.current_char.isalpha() or self.current_char == '_':
                tokens.append(self.identifier())
                continue
                
            # Handle dollar identifiers
            if self.current_char == '$':
                tokens.append(self.dollar_identifier())
                continue
                
            # Handle numbers
            if self.current_char.isdigit():
                tokens.append(self.number())
                continue
                
            # Handle strings
            if self.current_char == '"':
                tokens.append(self.string())
                continue
                
            # Handle hash directives
            if self.current_char == '#':
                tokens.append(self.hash_directive())
                continue
                
            # Handle at directives
            if self.current_char == '@':
                tokens.append(self.at_directive())
                continue
                
            # Handle operators and punctuation
            token = self.operator()
            if token:
                tokens.append(token)
                continue
                
            # If we get here, we encountered an unknown character
            raise LexerError(f"Unexpected character '{self.current_char}' at {self.line}:{self.column}")
        
        return tokens
    
    def identifier(self):
        """Parse an identifier or keyword."""
        line, column = self.line, self.column
        lexeme = ""
        
        while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):
            lexeme += self.current_char
            self.advance()
        
        # Check if this is a keyword
        if lexeme in self.keywords:
            token_type = self.keywords[lexeme]
            # Special handling for boolean literals
            if token_type == TokenType.KW_TRUE:
                return Token(TokenType.BOOL, lexeme, line, column, True)
            elif token_type == TokenType.KW_FALSE:
                return Token(TokenType.BOOL, lexeme, line, column, False)
            return Token(token_type, lexeme, line, column)
        
        # Regular identifier
        return Token(TokenType.IDENT, lexeme, line, column)
    
    def dollar_identifier(self):
        """Parse a dollar-prefixed identifier."""
        line, column = self.line, self.column
        self.advance()  # Skip $
        
        if not self.current_char or not (self.current_char.isalpha() or self.current_char == '_'):
            raise LexerError(f"Expected identifier after $ at {line}:{column}")
        
        name = ""
        while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):
            name += self.current_char
            self.advance()
        
        return Token(TokenType.DOLLAR_IDENT, f"${name}", line, column, name)
    
    def number(self):
        """Parse numeric literals: integers, hex, floats, or durations."""
        line, column = self.line, self.column
        
        # Check for hex
        if self.current_char == '0' and self.peek() and self.peek().lower() == 'x':
            return self.hex_number(line, column)
        
        # Parse the number part
        num_str = ""
        is_float = False
        
        while self.current_char and self.current_char.isdigit():
            num_str += self.current_char
            self.advance()
        
        # Check for decimal point (float)
        if self.current_char == '.':
            is_float = True
            num_str += self.current_char
            self.advance()
            
            # Must have at least one digit after decimal point
            if not self.current_char or not self.current_char.isdigit():
                raise LexerError(f"Expected digit after decimal point at {self.line}:{self.column}")
            
            while self.current_char and self.current_char.isdigit():
                num_str += self.current_char
                self.advance()
        
        # Check for duration suffix
        if self.current_char and self.current_char.isalpha():
            unit = ""
            
            # Get unit characters
            if self.current_char == 'n' and self.peek() == 's':
                unit = "ns"
                self.advance()
                self.advance()
            elif self.current_char == 'm' and self.peek() == 's':
                unit = "ms"
                self.advance()
                self.advance()
            elif self.current_char in ['s', 'm', 'h']:
                unit = self.current_char
                self.advance()
            
            if unit:
                # It's a duration
                if is_float:
                    base_value = float(num_str)
                else:
                    base_value = int(num_str)
                    
                # Convert to nanoseconds
                ns_value = int(base_value * TIME_UNITS[unit])
                return Token(TokenType.DURATION, f"{num_str}{unit}", line, column, ns_value)
        
        # Regular number
        if is_float:
            return Token(TokenType.FLOAT, num_str, line, column, float(num_str))
        else:
            return Token(TokenType.INT, num_str, line, column, int(num_str))
    
    def hex_number(self, line, column):
        """Parse a hexadecimal number."""
        lexeme = "0"
        self.advance()  # Skip '0'
        
        lexeme += self.current_char  # Add 'x'
        self.advance()  # Skip 'x'
        
        if not self.current_char or not self.current_char.lower() in "0123456789abcdef":
            raise LexerError(f"Expected hex digit after 0x at {self.line}:{self.column}")
        
        while self.current_char and self.current_char.lower() in "0123456789abcdef":
            lexeme += self.current_char
            self.advance()
        
        value = int(lexeme, 16)
        return Token(TokenType.HEX, lexeme, line, column, value)
    
    def string(self):
        """Parse a string literal."""
        line, column = self.line, self.column
        self.advance()  # Skip opening quote
        
        value = ""
        while self.current_char and self.current_char != '"':
            if self.current_char == '\\':
                self.advance()  # Skip backslash
                
                if not self.current_char:
                    raise LexerError(f"Unterminated string escape at {self.line}:{self.column}")
                
                # Handle escape sequences
                if self.current_char == 'n':
                    value += '\n'
                elif self.current_char == 't':
                    value += '\t'
                elif self.current_char == 'r':
                    value += '\r'
                elif self.current_char == '"':
                    value += '"'
                elif self.current_char == '\\':
                    value += '\\'
                elif self.current_char == 'x':
                    # Hex escape \xHH
                    if not self.peek() or not self.peek(2) or not (self.peek().lower() in "0123456789abcdef" and self.peek(2).lower() in "0123456789abcdef"):
                        raise LexerError(f"Invalid hex escape sequence at {self.line}:{self.column}")
                    
                    self.advance()  # Skip 'x'
                    hex_val = self.current_char + self.peek()
                    value += chr(int(hex_val, 16))
                    self.advance()  # Skip first hex digit
                else:
                    raise LexerError(f"Invalid escape sequence '\\{self.current_char}' at {self.line}:{self.column}")
            else:
                value += self.current_char
            
            self.advance()
        
        if not self.current_char:
            raise LexerError(f"Unterminated string starting at {line}:{column}")
        
        self.advance()  # Skip closing quote
        return Token(TokenType.STRING, f'"{value}"', line, column, value)
    
    def hash_directive(self):
        """Parse a hash directive."""
        line, column = self.line, self.column
        self.advance()  # Skip #
        
        # Get directive name
        name = ""
        while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):
            name += self.current_char
            self.advance()
        
        if not name:
            return Token(TokenType.HASH, "#", line, column)
        
        # Check if this is a known directive
        if name in self.hash_directives:
            return Token(self.hash_directives[name], f"#{name}", line, column)
        
        raise LexerError(f"Unknown hash directive '#{name}' at {line}:{column}")
    
    def at_directive(self):
        """Parse an at directive."""
        line, column = self.line, self.column
        self.advance()  # Skip @
        
        # Get directive name
        name = ""
        while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):
            name += self.current_char
            self.advance()
        
        if not name:
            return Token(TokenType.AT, "@", line, column)
        
        # Check if this is a known directive
        if name in self.at_directives:
            return Token(self.at_directives[name], f"@{name}", line, column)
        
        raise LexerError(f"Unknown at directive '@{name}' at {line}:{column}")
    
    def operator(self):
        """Parse operators and punctuation."""
        line, column = self.line, self.column
        
        # Single-character operators and punctuation
        if self.current_char == '+':
            self.advance()
            return Token(TokenType.PLUS, "+", line, column)
        elif self.current_char == '-':
            self.advance()
            return Token(TokenType.MINUS, "-", line, column)
        elif self.current_char == '*':
            self.advance()
            return Token(TokenType.STAR, "*", line, column)
        elif self.current_char == '/':
            self.advance()
            return Token(TokenType.SLASH, "/", line, column)
        elif self.current_char == '%':
            self.advance()
            return Token(TokenType.PERCENT, "%", line, column)
        elif self.current_char == '~':
            self.advance()
            return Token(TokenType.TILDE, "~", line, column)
        elif self.current_char == '(':
            self.advance()
            return Token(TokenType.LPAREN, "(", line, column)
        elif self.current_char == ')':
            self.advance()
            return Token(TokenType.RPAREN, ")", line, column)
        elif self.current_char == '{':
            self.advance()
            return Token(TokenType.LBRACE, "{", line, column)
        elif self.current_char == '}':
            self.advance()
            return Token(TokenType.RBRACE, "}", line, column)
        elif self.current_char == '[':
            self.advance()
            return Token(TokenType.LBRACKET, "[", line, column)
        elif self.current_char == ']':
            self.advance()
            return Token(TokenType.RBRACKET, "]", line, column)
        elif self.current_char == ',':
            self.advance()
            return Token(TokenType.COMMA, ",", line, column)
        elif self.current_char == ';':
            self.advance()
            return Token(TokenType.SEMICOLON, ";", line, column)
        elif self.current_char == ':':
            self.advance()
            return Token(TokenType.COLON, ":", line, column)
        elif self.current_char == '.':
            self.advance()
            return Token(TokenType.CARET, "^", line, column)
        
        # Two-character operators
        elif self.current_char == '=':
            self.advance()
            if self.current_char == '=':
                self.advance()
                return Token(TokenType.EQEQ, "==", line, column)
            return Token(TokenType.EQ, "=", line, column)
        elif self.current_char == '!':
            self.advance()
            if self.current_char == '=':
                self.advance()
                return Token(TokenType.BANGEQ, "!=", line, column)
            return Token(TokenType.BANG, "!", line, column)
        elif self.current_char == '<':
            self.advance()
            if self.current_char == '=':
                self.advance()
                return Token(TokenType.LTE, "<=", line, column)
            return Token(TokenType.LT, "<", line, column)
        elif self.current_char == '>':
            self.advance()
            if self.current_char == '=':
                self.advance()
                return Token(TokenType.GTE, ">=", line, column)
            return Token(TokenType.GT, ">", line, column)
        elif self.current_char == '&':
            self.advance()
            if self.current_char == '&':
                self.advance()
                return Token(TokenType.ANDAND, "&&", line, column)
            return Token(TokenType.AMP, "&", line, column)
        elif self.current_char == '|':
            self.advance()
            if self.current_char == '|':
                self.advance()
                return Token(TokenType.OROR, "||", line, column)
            return Token(TokenType.BAR, "|", line, column)
        
        return None

# ---- AST Node definitions ----
@dataclass
class Node:
    line: int
    column: int

@dataclass
class Expr(Node):
    pass

@dataclass
class Literal(Expr):
    kind: str
    value: Any

@dataclass
class Identifier(Expr):
    name: str
    is_dollar: bool = False

@dataclass
class UnaryOp(Expr):
    op: str
    rhs: Expr

@dataclass
class BinaryOp(Expr):
    op: str
    lhs: Expr
    rhs: Expr

@dataclass
class Program(Node):
    entry: 'EntryBlock'
    items: List[Union['Decl', 'Stmt']] = field(default_factory=list)

@dataclass
class EntryBlock(Node):
    kind: str
    block: 'Block'

@dataclass
class Block(Node):
    items: List[Union['Decl', 'Stmt']]

@dataclass
class Decl(Node):
    pass

@dataclass
class FunctionDecl(Decl):
    name: Identifier
    params: List['Param']
    return_type: Optional['TypeRef']
    body: Block

@dataclass
class WorkerDecl(Decl):
    name: Identifier
    params: List['Param']
    body: Block

@dataclass
class LetDecl(Decl):
    name: Identifier
    type_ref: 'TypeRef'

@dataclass
class ModuleDecl(Decl):
    path: str

@dataclass
class ExportDecl(Decl):
    symbol: Identifier

@dataclass
class ImportDecl(Decl):
    path: str
    alias: Optional[Identifier]

@dataclass
class Param(Node):
    name: Identifier
    type_ref: 'TypeRef'

@dataclass
class TypeRef(Node):
    kind: str
    name: Optional[str] = None
    inner: Optional['TypeRef'] = None
    size: Optional[int] = None

@dataclass
class Stmt(Node):
    pass

@dataclass
class InitStmt(Stmt):
    target: Identifier

@dataclass
class LoadStmt(Stmt):
    target: Identifier
    value: Expr

@dataclass
class CallStmt(Stmt):
    func: Identifier
    arg: Optional[Identifier] = None

@dataclass
class ExitStmt(Stmt):
    pass

@dataclass
class LeaseStmt(Stmt):
    target: Identifier

@dataclass
class SubleaseStmt(Stmt):
    target: Identifier

@dataclass
class ReleaseStmt(Stmt):
    target: Identifier

@dataclass
class CheckExpStmt(Stmt):
    target: Identifier

@dataclass
class RenderStmt(Stmt):
    target: Identifier

@dataclass
class InputStmt(Stmt):
    target: Identifier

@dataclass
class OutputStmt(Stmt):
    target: Identifier

@dataclass
class SendStmt(Stmt):
    chan: Identifier
    pkt: Identifier

@dataclass
class RecvStmt(Stmt):
    chan: Identifier
    pkt: Identifier

@dataclass
class SpawnStmt(Stmt):
    func: Identifier
    args: List[Union[Expr, Identifier]]

@dataclass
class JoinStmt(Stmt):
    thread: Identifier

@dataclass
class StampStmt(Stmt):
    target: Identifier
    value: Expr

@dataclass
class ExpireStmt(Stmt):
    target: Identifier
    duration: Literal

@dataclass
class SleepStmt(Stmt):
    duration: Literal

@dataclass
class YieldStmt(Stmt):
    pass

@dataclass
class ErrorStmt(Stmt):
    target: Identifier
    code: Expr
    message: Literal

@dataclass
class IfStmt(Stmt):
    cond: Expr
    then_block: Block
    else_block: Optional[Block] = None

@dataclass
class LoopStmt(Stmt):
    cond: Expr
    body: Block

@dataclass
class BreakStmt(Stmt):
    pass

@dataclass
class ContinueStmt(Stmt):
    pass

@dataclass
class GotoStmt(Stmt):
    label: str

@dataclass
class LabelStmt(Stmt):
    name: str

class ParserError(Exception):
    pass

class Parser:
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.current = 0
    
    def is_at_end(self):
        return self.current >= len(self.tokens)
    
    def peek(self):
        if self.is_at_end():
            return None
        return self.tokens[self.current]
    
    def previous(self):
        return self.tokens[self.current - 1]
    
    def advance(self):
        if not self.is_at_end():
            self.current += 1
        return self.previous()
    
    def match(self, *types):
        for type in types:
            if self.check(type):
                self.advance()
                return True
        return False
    
    def check(self, type):
        if self.is_at_end():
            return False
        return self.peek().type == type
    
    def consume(self, type, message):
        if self.check(type):
            return self.advance()
        
        token = self.peek()
        raise ParserError(f"{message} at {token.line}:{token.column}")
    
    def parse(self):
        """Parse a complete E Minor program."""
        entry = self.parse_entry_block()
        items = []
        
        while not self.is_at_end():
            token = self.peek()
            
            # Parse declarations
            if token.type in (TokenType.KW_FUNCTION, TokenType.KW_WORKER, TokenType.KW_LET,
                            TokenType.AT_MODULE, TokenType.AT_EXPORT, TokenType.AT_IMPORT):
                items.append(self.parse_declaration())
            else:
                # Parse statements
                items.append(self.parse_statement())
        
        return Program(line=entry.line, column=entry.column, entry=entry, items=items)
    
    def parse_entry_block(self):
        """Parse the program entry block (@main or @entry_point)."""
        token = self.consume(TokenType.AT_MAIN, "Expected @main or @entry_point")
        
        # Parse the block
        block = self.parse_block()
        
        return EntryBlock(line=token.line, column=token.column, kind=token.type.name, block=block)
    
    def parse_block(self):
        """Parse a block of statements."""
        open_brace = self.consume(TokenType.LBRACE, "Expected '{'")
        items = []
        
        while not self.check(TokenType.RBRACE) and not self.is_at_end():
            token = self.peek()
            
            # Parse declarations inside the block
            if token.type in (TokenType.KW_FUNCTION, TokenType.KW_WORKER, TokenType.KW_LET,
                            TokenType.AT_MODULE, TokenType.AT_EXPORT, TokenType.AT_IMPORT):
                items.append(self.parse_declaration())
            else:
                # Parse statements
                items.append(self.parse_statement())
        
        self.consume(TokenType.RBRACE, "Expected '}'")
        
        return Block(line=open_brace.line, column=open_brace.column, items=items)
    
    def parse_declaration(self):
        """Parse various declarations."""
        token = self.peek()
        
        if token.type == TokenType.KW_FUNCTION:
            return self.parse_function_declaration()
        elif token.type == TokenType.KW_WORKER:
            return self.parse_worker_declaration()
        elif token.type == TokenType.KW_LET:
            return self.parse_let_declaration()
        elif token.type == TokenType.AT_MODULE:
            return self.parse_module_declaration()
        elif token.type == TokenType.AT_EXPORT:
            return self.parse_export_declaration()
        elif token.type == TokenType.AT_IMPORT:
            return self.parse_import_declaration()
        
        raise ParserError(f"Unexpected token {token.type.name} at {token.line}:{token.column}")
    
    def parse_function_declaration(self):
        """Parse a function declaration."""
        keyword = self.consume(TokenType.KW_FUNCTION, "Expected 'function'")
        
        # Parse function name
        name = self.parse_dollar_identifier()
        
        # Parse parameters
        self.consume(TokenType.LPAREN, "Expected '(' after function name")
        params = []
        
        if not self.check(TokenType.RPAREN):
            params.append(self.parse_parameter())
            
            while self.match(TokenType.COMMA):
                params.append(self.parse_parameter())
        
        self.consume(TokenType.RPAREN, "Expected ')' after parameters")
        
        # Parse optional return type
        return_type = None
        if self.match(TokenType.COLON):
            return_type = self.parse_type()
        
        # Parse function body
        body = self.parse_block()
        
        return FunctionDecl(
            line=keyword.line,
            column=keyword.column,
            name=name,
            params=params,
            return_type=return_type,
            body=body
        )
    
    def parse_worker_declaration(self):
        """Parse a worker declaration."""
        keyword = self.consume(TokenType.KW_WORKER, "Expected 'worker'")
        
        # Parse worker name
        name = self.parse_dollar_identifier()
        
        # Parse parameters
        self.consume(TokenType.LPAREN, "Expected '(' after worker name")
        params = []
        
        if not self.check(TokenType.RPAREN):
            params.append(self.parse_parameter())
            
            while self.match(TokenType.COMMA):
                params.append(self.parse_parameter())
        
        self.consume(TokenType.RPAREN, "Expected ')' after parameters")
        
        # Parse worker body
        body = self.parse_block()
        
        return WorkerDecl(
            line=keyword.line,
            column=keyword.column,
            name=name,
            params=params,
            body=body
        )
    
    def parse_parameter(self):
        """Parse a function/worker parameter."""
        name = self.parse_dollar_identifier()
        
        self.consume(TokenType.COLON, "Expected ':' after parameter name")
        type_ref = self.parse_type()
        
        return Param(
            line=name.line,
            column=name.column,
            name=name,
            type_ref=type_ref
        )
    
    def parse_let_declaration(self):
        """Parse a let declaration."""
        keyword = self.consume(TokenType.KW_LET, "Expected 'let'")
        
        # Parse variable name
        name = self.parse_dollar_identifier()
        
        # Parse type
        self.consume(TokenType.COLON, "Expected ':' after variable name")
        type_ref = self.parse_type()
        
        self.consume(TokenType.SEMICOLON, "Expected ';' after let declaration")
        
        return LetDecl(
            line=keyword.line,
            column=keyword.column,
            name=name,
            type_ref=type_ref
        )
    
    def parse_module_declaration(self):
        """Parse a module declaration."""
        at_module = self.consume(TokenType.AT_MODULE, "Expected '@module'")
        
        # Parse module path
        path = self.consume(TokenType.STRING, "Expected string literal for module path").value
        
        return ModuleDecl(
            line=at_module.line,
            column=at_module.column,
            path=path
        )
    
    def parse_export_declaration(self):
        """Parse an export declaration."""
        at_export = self.consume(TokenType.AT_EXPORT, "Expected '@export'")
        
        # Skip optional 'function' keyword
        self.match(TokenType.KW_FUNCTION)
        
        # Parse symbol to export
        symbol = self.parse_dollar_identifier()
        
        return ExportDecl(
            line=at_export.line,
            column=at_export.column,
            symbol=symbol
        )
    
    def parse_import_declaration(self):
        """Parse an import declaration."""
        at_import = self.consume(TokenType.AT_IMPORT, "Expected '@import'")
        
        # Parse import path
        path = self.consume(TokenType.STRING, "Expected string literal for import path").value
        
        # Parse optional alias
        alias = None
        if self.match(TokenType.IDENT) and self.previous().lexeme == "as":
            alias = self.parse_dollar_identifier()
        
        return ImportDecl(
            line=at_import.line,
            column=at_import.column,
            path=path,
            alias=alias
        )
    
    def parse_type(self):
        """Parse a type reference."""
        token = self.peek()
        
        # Handle byte array type
        if token.type == TokenType.KW_BYTE:
            byte_token = self.advance()
            self.consume(TokenType.LBRACKET, "Expected '[' after 'byte'")
            size = self.consume(TokenType.INT, "Expected integer size for byte array").value
            self.consume(TokenType.RBRACKET, "Expected ']' after byte array size")
            
            return TypeRef(
                line=byte_token.line,
                column=byte_token.column,
                kind="byte_array",
                size=size
            )
        
        # Handle capsule/packet types
        if token.type in (TokenType.KW_CAPSULE, TokenType.IDENT) and token.lexeme in ("capsule", "packet"):
            head_token = self.advance()
            kind = head_token.lexeme
            
            self.consume(TokenType.LT, "Expected '<' after capsule/packet")
            inner = self.parse_type()
            self.consume(TokenType.GT, "Expected '>' after inner type")
            
            return TypeRef(
                line=head_token.line,
                column=head_token.column,
                kind=kind,
                inner=inner
            )
        
        # Handle primitive types
        if token.type in (
            TokenType.KW_U8, TokenType.KW_U16, TokenType.KW_U32, TokenType.KW_U64,
            TokenType.KW_I8, TokenType.KW_I16, TokenType.KW_I32, TokenType.KW_I64,
            TokenType.KW_F32, TokenType.KW_F64, TokenType.KW_BOOL, TokenType.KW_STAMP, TokenType.KW_DURATION
        ):
            prim_token = self.advance()
            
            return TypeRef(
                line=prim_token.line,
                column=prim_token.column,
                kind="prim",
                name=prim_token.lexeme
            )
        
        raise ParserError(f"Expected type but got {token.type.name} at {token.line}:{token.column}")
    
    def parse_dollar_identifier(self):
        """Parse a dollar-prefixed identifier."""
        token = self.consume(TokenType.DOLLAR_IDENT, "Expected $identifier")
        
        return Identifier(
            line=token.line,
            column=token.column,
            name=token.value,
            is_dollar=True
        )
    
    def parse_statement(self):
        """Parse a statement."""
        token = self.peek()
        
        # Label statement
        if token.type == TokenType.COLON:
            colon = self.advance()
            name = self.consume(TokenType.IDENT, "Expected identifier after ':'").lexeme
            
            return LabelStmt(
                line=colon.line,
                column=colon.column,
                name=name
            )
        
        # Hash directives
        if token.type == TokenType.HASH_INIT:
            return self.parse_init_stmt()
        elif token.type == TokenType.HASH_LOAD:
            return self.parse_load_stmt()
        elif token.type == TokenType.HASH_CALL:
            return self.parse_call_stmt()
        elif token.type == TokenType.HASH_EXIT:
            return self.parse_exit_stmt()
        elif token.type == TokenType.HASH_LEASE:
            return self.parse_lease_stmt()
        elif token.type == TokenType.HASH_SUBLEASE:
            return self.parse_sublease_stmt()
        elif token.type == TokenType.HASH_RELEASE:
            return self.parse_release_stmt()
        elif token.type == TokenType.HASH_CHECK_EXP:
            return self.parse_check_exp_stmt()
        elif token.type == TokenType.HASH_RENDER:
            return self.parse_render_stmt()
        elif token.type == TokenType.HASH_INPUT:
            return self.parse_input_stmt()
        elif token.type == TokenType.HASH_OUTPUT:
            return self.parse_output_stmt()
        elif token.type == TokenType.HASH_SEND:
            return self.parse_send_stmt()
        elif token.type == TokenType.HASH_RECV:
            return self.parse_recv_stmt()
        elif token.type == TokenType.HASH_SPAWN:
            return self.parse_spawn_stmt()
        elif token.type == TokenType.HASH_JOIN:
            return self.parse_join_stmt()
        elif token.type == TokenType.HASH_STAMP:
            return self.parse_stamp_stmt()
        elif token.type == TokenType.HASH_EXPIRE:
            return self.parse_expire_stmt()
        elif token.type == TokenType.HASH_SLEEP:
            return self.parse_sleep_stmt()
        elif token.type == TokenType.HASH_YIELD:
            return self.parse_yield_stmt()
        elif token.type == TokenType.HASH_ERROR:
            return self.parse_error_stmt()
        elif token.type == TokenType.HASH_IF:
            return self.parse_if_stmt()
        elif token.type == TokenType.HASH_LOOP:
            return self.parse_loop_stmt()
        elif token.type == TokenType.HASH_BREAK:
            return self.parse_break_stmt()
        elif token.type == TokenType.HASH_CONTINUE:
            return self.parse_continue_stmt()
        
        # Long-form statements
        elif token.type == TokenType.KW_INITIALIZE:
            return self.parse_longform_init_stmt()
        elif token.type == TokenType.KW_ASSIGN:
            return self.parse_longform_load_stmt()
        elif token.type == TokenType.KW_INVOKE:
            return self.parse_longform_call_stmt()
        elif token.type == TokenType.KW_TERMINATE:
            return self.parse_longform_exit_stmt()
        elif token.type == TokenType.KW_GOTO:
            return self.parse_goto_stmt()
        
        raise ParserError(f"Unexpected token {token.type.name} at {token.line}:{token.column}")
    
    def parse_init_stmt(self):
        """Parse #init statement."""
        directive = self.consume(TokenType.HASH_INIT, "Expected #init")
        target = self.parse_dollar_identifier()
        
        return InitStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_load_stmt(self):
        """Parse #load statement."""
        directive = self.consume(TokenType.HASH_LOAD, "Expected #load")
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after target in #load")
        value = self.parse_value_expr()
        
        return LoadStmt(
            line=directive.line,
            column=directive.column,
            target=target,
            value=value
        )
    
    def parse_call_stmt(self):
        """Parse #call statement."""
        directive = self.consume(TokenType.HASH_CALL, "Expected #call")
        func = self.parse_dollar_identifier()
        
        arg = None
        if self.match(TokenType.COMMA):
            arg = self.parse_dollar_identifier()
        
        return CallStmt(
            line=directive.line,
            column=directive.column,
            func=func,
            arg=arg
        )
    
    def parse_exit_stmt(self):
        """Parse #exit statement."""
        directive = self.consume(TokenType.HASH_EXIT, "Expected #exit")
        
        return ExitStmt(
            line=directive.line,
            column=directive.column
        )
    
    def parse_lease_stmt(self):
        """Parse #lease statement."""
        directive = self.consume(TokenType.HASH_LEASE, "Expected #lease")
        target = self.parse_dollar_identifier()
        
        return LeaseStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_sublease_stmt(self):
        """Parse #sublease statement."""
        directive = self.consume(TokenType.HASH_SUBLEASE, "Expected #sublease")
        target = self.parse_dollar_identifier()
        
        return SubleaseStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_release_stmt(self):
        """Parse #release statement."""
        directive = self.consume(TokenType.HASH_RELEASE, "Expected #release")
        target = self.parse_dollar_identifier()
        
        return ReleaseStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_check_exp_stmt(self):
        """Parse #check_exp statement."""
        directive = self.consume(TokenType.HASH_CHECK_EXP, "Expected #check_exp")
        target = self.parse_dollar_identifier()
        
        return CheckExpStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_render_stmt(self):
        """Parse #render statement."""
        directive = self.consume(TokenType.HASH_RENDER, "Expected #render")
        target = self.parse_dollar_identifier()
        
        return RenderStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_input_stmt(self):
        """Parse #input statement."""
        directive = self.consume(TokenType.HASH_INPUT, "Expected #input")
        target = self.parse_dollar_identifier()
        
        return InputStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_output_stmt(self):
        """Parse #output statement."""
        directive = self.consume(TokenType.HASH_OUTPUT, "Expected #output")
        target = self.parse_dollar_identifier()
        
        return OutputStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_send_stmt(self):
        """Parse #send statement."""
        directive = self.consume(TokenType.HASH_SEND, "Expected #send")
        chan = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after channel in #send")
        pkt = self.parse_dollar_identifier()
        
        return SendStmt(
            line=directive.line,
            column=directive.column,
            chan=chan,
            pkt=pkt
        )
    
    def parse_recv_stmt(self):
        """Parse #recv statement."""
        directive = self.consume(TokenType.HASH_RECV, "Expected #recv")
        chan = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after channel in #recv")
        pkt = self.parse_dollar_identifier()
        
        return RecvStmt(
            line=directive.line,
            column=directive.column,
            chan=chan,
            pkt=pkt
        )
    
    def parse_spawn_stmt(self):
        """Parse #spawn statement."""
        directive = self.consume(TokenType.HASH_SPAWN, "Expected #spawn")
        func = self.parse_dollar_identifier()
        
        args = []
        if self.match(TokenType.COMMA):
            args.append(self.parse_arg())
            
            while self.match(TokenType.COMMA):
                args.append(self.parse_arg())
        
        return SpawnStmt(
            line=directive.line,
            column=directive.column,
            func=func,
            args=args
        )
    
    def parse_arg(self):
        """Parse an argument for spawn."""
        token = self.peek()
        
        if token.type == TokenType.DOLLAR_IDENT:
            return self.parse_dollar_identifier()
        elif token.type in (TokenType.INT, TokenType.HEX, TokenType.FLOAT, TokenType.DURATION, TokenType.STRING, TokenType.BOOL):
            return self.parse_value_expr()
        
        return self.parse_expr()
    
    def parse_join_stmt(self):
        """Parse #join statement."""
        directive = self.consume(TokenType.HASH_JOIN, "Expected #join")
        thread = self.parse_dollar_identifier()
        
        return JoinStmt(
            line=directive.line,
            column=directive.column,
            thread=thread
        )
    
    def parse_stamp_stmt(self):
        """Parse #stamp statement."""
        directive = self.consume(TokenType.HASH_STAMP, "Expected #stamp")
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after target in #stamp")
        value = self.parse_value_expr()
        
        return StampStmt(
            line=directive.line,
            column=directive.column,
            target=target,
            value=value
        )
    
    def parse_expire_stmt(self):
        """Parse #expire statement."""
        directive = self.consume(TokenType.HASH_EXPIRE, "Expected #expire")
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after target in #expire")
        duration_token = self.consume(TokenType.DURATION, "Expected duration value")
        
        duration = Literal(
            line=duration_token.line,
            column=duration_token.column,
            kind="DURATION",
            value=duration_token.value
        )
        
        return ExpireStmt(
            line=directive.line,
            column=directive.column,
            target=target,
            duration=duration
        )
    
    def parse_sleep_stmt(self):
        """Parse #sleep statement."""
        directive = self.consume(TokenType.HASH_SLEEP, "Expected #sleep")
        duration_token = self.consume(TokenType.DURATION, "Expected duration value")
        
        duration = Literal(
            line=duration_token.line,
            column=duration_token.column,
            kind="DURATION",
            value=duration_token.value
        )
        
        return SleepStmt(
            line=directive.line,
            column=directive.column,
            duration=duration
        )
    
    def parse_yield_stmt(self):
        """Parse #yield statement."""
        directive = self.consume(TokenType.HASH_YIELD, "Expected #yield")
        
        return YieldStmt(
            line=directive.line,
            column=directive.column
        )
    
    def parse_error_stmt(self):
        """Parse #error statement."""
        directive = self.consume(TokenType.HASH_ERROR, "Expected #error")
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.COMMA, "Expected ',' after target in #error")
        code = self.parse_value_expr()
        
        self.consume(TokenType.COMMA, "Expected ',' after code in #error")
        msg_token = self.consume(TokenType.STRING, "Expected string message")
        
        message = Literal(
            line=msg_token.line,
            column=msg_token.column,
            kind="STRING",
            value=msg_token.value
        )
        
        return ErrorStmt(
            line=directive.line,
            column=directive.column,
            target=target,
            code=code,
            message=message
        )
    
    def parse_if_stmt(self):
        """Parse #if statement."""
        directive = self.consume(TokenType.HASH_IF, "Expected #if")
        
        self.consume(TokenType.LPAREN, "Expected '(' after #if")
        cond = self.parse_expr()
        self.consume(TokenType.RPAREN, "Expected ')' after condition")
        
        then_block = self.parse_block()
        
        else_block = None
        if self.match(TokenType.HASH_ELSE):
            else_block = self.parse_block()
        
        self.consume(TokenType.HASH_ENDIF, "Expected #endif after if statement")
        
        return IfStmt(
            line=directive.line,
            column=directive.column,
            cond=cond,
            then_block=then_block,
            else_block=else_block
        )
    
    def parse_loop_stmt(self):
        """Parse #loop statement."""
        directive = self.consume(TokenType.HASH_LOOP, "Expected #loop")
        
        self.consume(TokenType.LPAREN, "Expected '(' after #loop")
        cond = self.parse_expr()
        self.consume(TokenType.RPAREN, "Expected ')' after condition")
        
        body = self.parse_block()
        
        return LoopStmt(
            line=directive.line,
            column=directive.column,
            cond=cond,
            body=body
        )
    
    def parse_break_stmt(self):
        """Parse #break statement."""
        directive = self.consume(TokenType.HASH_BREAK, "Expected #break")
        
        return BreakStmt(
            line=directive.line,
            column=directive.column
        )
    
    def parse_continue_stmt(self):
        """Parse #continue statement."""
        directive = self.consume(TokenType.HASH_CONTINUE, "Expected #continue")
        
        return ContinueStmt(
            line=directive.line,
            column=directive.column
        )
    
    def parse_goto_stmt(self):
        """Parse #goto statement."""
        directive = self.consume(TokenType.KW_GOTO, "Expected 'goto'")
        
        target = self.consume(TokenType.IDENT, "Expected label name after goto")
        
        return GotoStmt(
            line=directive.line,
            column=directive.column,
            label=target.lexeme
        )
    
    def parse_longform_init_stmt(self):
        """Parse long-form initialize statement (initialize ... to ...)."""
        directive = self.consume(TokenType.KW_INITIALIZE, "Expected 'initialize'")
        
        # Parse capsule name
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.KW_TO, "Expected 'to' after initialize target")
        
        # Parse initial value
        value = self.parse_value_expr()
        
        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form initialize")
        
        return InitStmt(
            line=directive.line,
            column=directive.column,
            target=target
        )
    
    def parse_longform_load_stmt(self):
        """Parse long-form load statement (assign ... value ...)."""
        directive = self.consume(TokenType.KW_ASSIGN, "Expected 'assign'")
        
        # Parse target capsule/packet
        target = self.parse_dollar_identifier()
        
        self.consume(TokenType.KW_VALUE, "Expected 'value' after assign target")
        
        # Parse value expression
        value = self.parse_value_expr()
        
        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form load")
        
        return LoadStmt(
            line=directive.line,
            column=directive.column,
            target=target,
            value=value
        )
    
    def parse_longform_call_stmt(self):
        """Parse long-form call statement (invoke ... with ...)."""
        directive = self.consume(TokenType.KW_INVOKE, "Expected 'invoke'")
        
        # Parse function name
        func = self.parse_dollar_identifier()
        
        args = []
        if self.match(TokenType.KW_WITH):
            self.consume(TokenType.LPAREN, "Expected '(' after with")
            
            if not self.check(TokenType.RPAREN):
                args.append(self.parse_arg())
                
                while self.match(TokenType.COMMA):
                    args.append(self.parse_arg())
            
            self.consume(TokenType.RPAREN, "Expected ')' after arguments")
        
        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form call")
        
        return CallStmt(
            line=directive.line,
            column=directive.column,
            func=func,
            args=args
        )
    
    def parse_longform_exit_stmt(self):
        """Parse long-form exit statement (terminate ...)."""
        directive = self.consume(TokenType.KW_TERMINATE, "Expected 'terminate'")
        
        args = []
        if not self.check(TokenType.SEMICOLON):
            args.append(self.parse_value_expr())
            
            while self.match(TokenType.COMMA):
                args.append(self.parse_value_expr())
        
        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form terminate")
        
        return ExitStmt(
            line=directive.line,
            column=directive.column
        )
    
    def parse_value_expr(self):
        """Parse a value expression (literal, identifier, or expression)."""
        token = self.peek()
        
        if token.type in (TokenType.INT, TokenType.HEX, TokenType.FLOAT, TokenType.DURATION, TokenType.STRING, TokenType.BOOL):
            t = self.advance()
            return Literal(line=t.line, column=t.column, kind=t.type.name, value=t.value)
        
        return self.parse_expr()
    
    def parse_expr(self):
        """Parse an expression."""
        return self.parse_logical_or()
    
    def parse_logical_or(self):
        """Parse logical OR expressions."""
        expr = self.parse_logical_and()
        
        while self.match(TokenType.OROR):
            op = self.previous()
            right = self.parse_logical_and()
            expr = BinaryOp(line=expr.line, column=expr.column, op="||", lhs=expr, rhs=right)
        
        return expr
    
    def parse_logical_and(self):
        """Parse logical AND expressions."""
        expr = self.parse_equality()
        
        while self.match(TokenType.ANDAND):
            op = self.previous()
            right = self.parse_equality()
            expr = BinaryOp(line=expr.line, column=expr.column, op="&&", lhs=expr, rhs=right)
        
        return expr
    
    def parse_equality(self):
        """Parse equality expressions."""
        expr = self.parse_comparison()
        
        while self.match(TokenType.EQEQ, TokenType.BANGEQ):
            op = self.previous()
            right = self.parse_comparison()
            expr = BinaryOp(line=expr.line, column=expr.column, 
                           op="==" if op.type == TokenType.EQEQ else "!=", 
                           lhs=expr, rhs=right)
        
        return expr
    
    def parse_comparison(self):
        """Parse comparison expressions."""
        expr = self.parse_addition()
        
        while self.match(TokenType.LT, TokenType.GT, TokenType.LTE, TokenType.GTE):
            op = self.previous()
            right = self.parse_addition()
            
            if op.type == TokenType.LT:
                op_str = "<"
            elif op.type == TokenType.GT:
                op_str = ">"
            elif op.type == TokenType.LTE:
                op_str = "<="
            else:
                op_str = ">="
                
            expr = BinaryOp(line=expr.line, column=expr.column, op=op_str, lhs=expr, rhs=right)
        
        return expr
    
    def parse_addition(self):
        """Parse addition and subtraction expressions."""
        expr = self.parse_multiplication()
        
        while self.match(TokenType.PLUS, TokenType.MINUS):
            op = self.previous()
            right = self.parse_multiplication()
            expr = BinaryOp(line=expr.line, column=expr.column, 
                           op="+" if op.type == TokenType.PLUS else "-", 
                           lhs=expr, rhs=right)
        
        return expr
    
    def parse_multiplication(self):
        """Parse multiplication, division, and modulo expressions."""
        expr = self.parse_unary()
        
        while self.match(TokenType.STAR, TokenType.SLASH, TokenType.PERCENT):
            op = self.previous()
            right = self.parse_unary()
            
            if op.type == TokenType.STAR:
                op_str = "*"
            elif op.type == TokenType.SLASH:
                op_str = "/"
            else:
                op_str = "%"
                
            expr = BinaryOp(line=expr.line, column=expr.column, op=op_str, lhs=expr, rhs=right)
        
        return expr
    
    def parse_unary(self):
        """Parse unary expressions."""
        if self.match(TokenType.BANG, TokenType.TILDE, TokenType.MINUS):
            op = self.previous()
            right = self.parse_unary()
            
            if op.type == TokenType.BANG:
                op_str = "!"
            elif op.type == TokenType.TILDE:
                op_str = "~"
            else:
                op_str = "u-"  # unary minus
                
            return UnaryOp(line=op.line, column=op.column, op=op_str, rhs=right)
        
        return self.parse_primary()
    
    def parse_primary(self):
        """Parse primary expressions (literals, identifiers, parenthesized expressions)."""
        token = self.peek()
        
        if token.type in (TokenType.INT, TokenType.HEX, TokenType.FLOAT, TokenType.DURATION, TokenType.STRING, TokenType.BOOL):
            t = self.advance()
            return Literal(line=t.line, column=t.column, kind=t.type.name, value=t.value)
        elif token.type == TokenType.DOLLAR_IDENT:
            return self.parse_dollar_identifier()
        elif token.type == TokenType.IDENT:
            t = self.advance()
            return Identifier(line=t.line, column=t.column, name=t.lexeme, is_dollar=False)
        elif token.type == TokenType.LPAREN:
            self.advance()
            expr = self.parse_expr()
            self.consume(TokenType.RPAREN, "Expected ')' after expression")
            return expr
        
        raise ParserError(f"Expected expression but got {token.type.name} at {token.line}:{token.column}")

# Fix for error on line 803 - incorrect token creation syntax
# include Token(TokenType.BAR, "|", line, column)

# Fix for error on line 2583 - single brace in f-string (in _generate_c_runtime)
# The original code has an unescaped single brace in an f-string
# The corrected line should have double braces where single braces were intended to be literal:
# Change: print(f"... {... { ... } ...")
# To:     print(f"... {... {{ ... }} ...")

class ConstantPool:
    """Manages constants for code generation."""
    def __init__(self):
        self.constants = []
        self.constant_map = {}  # For deduplication
    
    def add(self, kind: str, value: Any) -> int:
        """Add a constant to the pool and return its index."""
        key = (kind, self._make_hashable(value))
        if key in self.constant_map:
            return self.constant_map[key]
            
        index = len(self.constants)
        self.constants.append({"kind": kind, "value": value})
        self.constant_map[key] = index
        return index
    
    def _make_hashable(self, value):
        """Convert a value to a hashable form."""
        if isinstance(value, list):
            return tuple(self._make_hashable(v) for v in value)
        elif isinstance(value, dict):
            return tuple(sorted((k, self._make_hashable(v)) for k, v in value.items()))
        return value

class SymbolTable:
    """Manages symbol resolution during code generation."""
    def __init__(self):
        self.scopes = [{}]  # Stack of scopes
        self.functions = {}  # name -> index
        self.globals = {}    # name -> index
        self.capsules = {}   # name -> id
        self.label_offsets = {}  # label -> bytecode offset
        self.next_label = 0  # For generating unique labels
    
    def enter_scope(self):
        """Enter a new scope."""
        self.scopes.append({})
    
    def exit_scope(self):
        """Exit the current scope."""
        self.scopes.pop()
    
    def define(self, name: str, type_info: Dict):
        """Define a symbol in the current scope."""
        self.scopes[-1][name] = type_info
    
    def resolve(self, name: str) -> Optional[Dict]:
        """Resolve a symbol in any visible scope."""
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        return None
    
    def add_function(self, name: str) -> int:
        """Register a function and return its index."""
        if name in self.functions:
            return self.functions[name]
        index = len(self.functions)
        self.functions[name] = index
        return index
    
    def add_global(self, name: str) -> int:
        """Register a global variable and return its index."""
        if name in self.globals:
            return self.globals[name]
        index = len(self.globals)
        self.globals[name] = index
        return index
    
    def assign_capsule_id(self, name: str) -> int:
        """Assign a unique ID to a capsule."""
        if name in self.capsules:
            return self.capsules[name]
        
        # Generate a deterministic ID based on name
        capsule_id = hash(name) & 0xFF
        self.capsules[name] = capsule_id
        return capsule_id
    
    def generate_label(self) -> str:
        """Generate a unique label for jumps."""
        label = f"L{self.next_label}"
        self.next_label += 1
        return label
    
    def set_label_offset(self, label: str, offset: int):
        """Set the bytecode offset for a label."""
        self.label_offsets[label] = offset
    
    def get_label_offset(self, label: str) -> Optional[int]:
        """Get the bytecode offset for a label."""
        return self.label_offsets.get(label)

class CodeGenerator:
    """Generates bytecode from an AST."""
    def __init__(self):
        self.bytecode = bytearray()
        self.symbols = SymbolTable()
        self.constants = ConstantPool()
        self.fixups = []  # (offset, target_label) for unresolved jumps
    
    def emit(self, *bytes_):
        """Emit bytes to the bytecode."""
        for b in bytes_:
            self.bytecode.append(b & 0xFF)
    
    def emit_u16(self, value: int):
        """Emit a 16-bit unsigned integer."""
        self.emit((value >> 8) & 0xFF, value & 0xFF)
    
    def current_offset(self) -> int:
        """Get the current bytecode offset."""
        return len(self.bytecode)
    
    def patch_jump(self, jump_offset: int, target_offset: int):
        """Patch a jump instruction with the correct offset."""
        relative = target_offset - (jump_offset + 2)  # +2 for the offset itself
        self.bytecode[jump_offset] = (relative >> 8) & 0xFF
        self.bytecode[jump_offset + 1] = relative & 0xFF
    
    def generate(self, program: Program) -> Tuple[bytearray, Dict]:
        """Generate bytecode from an AST."""
        self.bytecode = bytearray()
        self.symbols = SymbolTable()
        self.constants = ConstantPool()
        self.fixups = []
        
        # Process declarations first to build symbol table
        for item in program.items:
            if isinstance(item, Decl):
                self.process_declaration(item)
        
        # Process the entry point
        self.generate_block(program.entry.block)
        
        # End the program
        self.emit(OPCODES["END"])
        
        # Process fixups for jumps
        for offset, target_label in self.fixups:
            target_offset = self.symbols.get_label_offset(target_label)
            if target_offset is not None:
                self.patch_jump(offset, target_offset)
        
        return self.bytecode, {
            "constants": self.constants.constants,
            "functions": self.symbols.functions,
            "capsules": self.symbols.capsules,
            "globals": self.symbols.globals
        }
    
    def process_declaration(self, decl: Decl):
        """Process a declaration to build the symbol table."""
        if isinstance(decl, FunctionDecl):
            self.symbols.add_function(decl.name.name)
        elif isinstance(decl, LetDecl):
            self.symbols.add_global(decl.name.name)
            self.symbols.assign_capsule_id(decl.name.name)
    
    def generate_block(self, block: Block):
        """Generate code for a block of statements."""
        self.symbols.enter_scope()
        
        for item in block.items:
            if isinstance(item, Stmt):
                self.generate_statement(item)
            elif isinstance(item, Decl):
                self.generate_declaration(item)
        
        self.symbols.exit_scope()
    
    def generate_declaration(self, decl: Decl):
        """Generate code for a declaration."""
        if isinstance(decl, FunctionDecl):
            # Function definitions are handled separately
            pass
        elif isinstance(decl, LetDecl):
            # Let declarations don't generate code directly
            pass
    
    def generate_statement(self, stmt: Stmt):
        """Generate code for a statement."""
        if isinstance(stmt, InitStmt):
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            self.emit(OPCODES["INIT"], capsule_id)
        
        elif isinstance(stmt, LoadStmt):
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            self.generate_expression(stmt.value)  # Push value onto stack
            self.emit(OPCODES["LOAD"], capsule_id)
        
        elif isinstance(stmt, CallStmt):
            func_idx = self.symbols.add_function(stmt.func.name)
            if stmt.arg:
                capsule_id = self.symbols.assign_capsule_id(stmt.arg.name)
                self.emit(OPCODES["CALLA"], (func_idx >> 8) & 0xFF, func_idx & 0xFF, capsule_id)
            else:
                self.emit(OPCODES["CALL"], (func_idx >> 8) & 0xFF, func_idx & 0xFF)
        
        elif isinstance(stmt, ExitStmt):
            self.emit(OPCODES["EXIT"])
        
        elif isinstance(stmt, LeaseStmt):
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            self.emit(OPCODES["LEASE"], capsule_id)
        
        elif isinstance(stmt, SubleaseStmt):
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            self.emit(OPCODES["SUBLEASE"], capsule_id)
        
        elif isinstance(stmt, ReleaseStmt):
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            self.emit(OPCODES["RELEASE"], capsule_id)
        
        elif isinstance(stmt, SleepStmt):
            const_idx = self.constants.add("DURATION", stmt.duration.value)
            self.emit(OPCODES["SLEEP"])
            self.emit_u16(const_idx)
        
        elif isinstance(stmt, YieldStmt):
            self.emit(OPCODES["YIELD"])
        
        elif isinstance(stmt, LabelStmt):
            # Record the label's position in the bytecode
            self.symbols.set_label_offset(stmt.name, self.current_offset())
        
        elif isinstance(stmt, GotoStmt):
            # Emit a jump instruction
            self.emit(OPCODES["JMP"])
            fixup_offset = self.current_offset()
            self.emit_u16(0)  # Placeholder
            self.fixups.append((fixup_offset, stmt.label))
        
        elif isinstance(stmt, IfStmt):
            self.generate_if_statement(stmt)
        
        elif isinstance(stmt, LoopStmt):
            self.generate_loop_statement(stmt)
    
    def generate_if_statement(self, stmt: IfStmt):
        """Generate code for an if statement."""
        # Generate condition code
        self.generate_expression(stmt.cond)
        
        # Jump if false
        self.emit(OPCODES["JZ"])
        else_jump = self.current_offset()
        self.emit_u16(0)  # Placeholder
        
        # Generate then block
        self.generate_block(stmt.then_block)
        
        if stmt.else_block:
            # Jump over else block
            self.emit(OPCODES["JMP"])
            end_jump = self.current_offset()
            self.emit_u16(0)  # Placeholder
            
            # Patch else jump to here
            else_offset = self.current_offset()
            self.patch_jump(else_jump, else_offset)
            
            # Generate else block
            self.generate_block(stmt.else_block)
            
            # Patch end jump to here
            end_offset = self.current_offset()
            self.patch_jump(end_jump, end_offset)
        else:
            # No else block, patch jump to here
            end_offset = self.current_offset()
            self.patch_jump(else_jump, end_offset)
    
    def generate_loop_statement(self, stmt: LoopStmt):
        """Generate code for a loop statement."""
        loop_start = self.current_offset()
        
        # Generate condition
        self.generate_expression(stmt.cond)
        
        # Jump out of loop if condition is false
        self.emit(OPCODES["JZ"])
        exit_jump = self.current_offset()
        self.emit_u16(0)  # Placeholder
        
        # Generate loop body
        self.generate_block(stmt.body)
        
        # Jump back to start
        self.emit(OPCODES["JMP"])
        self.emit_u16(loop_start - (self.current_offset() + 2))
        
        # Patch exit jump
        exit_offset = self.current_offset()
        self.patch_jump(exit_jump, exit_offset)

# Add these methods to VirtualMachine class

def run_with_timeout(self, timeout_ms: int = 10000):
    """Execute with timeout protection."""
    start_time = time.time()
    
    def check_timeout():
        elapsed = (time.time() - start_time) * 1000
        if elapsed > timeout_ms:
            raise TimeoutError(f"Program execution exceeded {timeout_ms}ms timeout")
    
    while self.pc < len(self.bytecode):
        check_timeout()
        
        if not self.execute_instruction():
            break

def execute_instruction(self) -> bool:
    """Execute a single instruction. Returns False if execution should stop."""
    if self.pc >= len(self.bytecode):
        return False
        
    opcode = self.bytecode[self.pc]
    self.pc += 1
    
    # Execute the opcode (using the existing run() logic)
    if opcode == OPCODES["END"]:
        return False
    
    # Handle all other opcodes as in the original run() method
    # (I'm not repeating the full implementation for brevity)
    
    return True

# Additional opcode implementations for completeness

def handle_render(self):
    """Process RENDER opcode."""
    capsule_id = self.bytecode[self.pc]
    self.pc += 1
    
    value = self.capsules.get(capsule_id)
    if value is not None:
        print(f"RENDER: {value}")
    else:
        print(f"RENDER: <null>")
        
def handle_input(self):
    """Process INPUT opcode."""
    capsule_id = self.bytecode[self.pc]
    self.pc += 1
    
    try:
        value = input("INPUT> ")
        self.capsules[capsule_id] = value
    except EOFError:
        self.capsules[capsule_id] = ""
        
def handle_send_recv(self, is_send: bool):
    """Process SEND/RECV opcodes."""
    chan_id = self.bytecode[self.pc]
    self.pc += 1
    pkt_id = self.bytecode[self.pc]
    self.pc += 1
    
    # In a real implementation, we would have channel objects
    # This is a simplified version that just prints the operation
    if is_send:
        print(f"SEND: Channel {chan_id} â† Packet {pkt_id} with value {self.capsules.get(pkt_id)}")
    else:
        print(f"RECV: Channel {chan_id} â†’ Packet {pkt_id}")
        # For testing, just store a dummy value
        self.capsules[pkt_id] = f"received_data_{chan_id}"
# Add these methods to VirtualMachine class

def run_with_timeout(self, timeout_ms: int = 10000):
    """Execute with timeout protection."""
    start_time = time.time()
    
    def check_timeout():
        elapsed = (time.time() - start_time) * 1000
        if elapsed > timeout_ms:
            raise TimeoutError(f"Program execution exceeded {timeout_ms}ms timeout")
    
    while self.pc < len(self.bytecode):
        check_timeout()
        
        if not self.execute_instruction():
            break

def execute_instruction(self) -> bool:
    """Execute a single instruction. Returns False if execution should stop."""
    if self.pc >= len(self.bytecode):
        return False
        
    opcode = self.bytecode[self.pc]
    self.pc += 1
    
    # Execute the opcode (using the existing run() logic)
    if opcode == OPCODES["END"]:
        return False
    
    # Handle all other opcodes as in the original run() method
    # (I'm not repeating the full implementation for brevity)
    
    return True

# Additional opcode implementations for completeness

def handle_render(self):
    """Process RENDER opcode."""
    capsule_id = self.bytecode[self.pc]
    self.pc += 1
    
    value = self.capsules.get(capsule_id)
    if value is not None:
        print(f"RENDER: {value}")
    else:
        print(f"RENDER: <null>")
        
def handle_input(self):
    """Process INPUT opcode."""
    capsule_id = self.bytecode[self.pc]
    self.pc += 1
    
    try:
        value = input("INPUT> ")
        self.capsules[capsule_id] = value
    except EOFError:
        self.capsules[capsule_id] = ""
        
def handle_send_recv(self, is_send: bool):
    """Process SEND/RECV opcodes."""
    chan_id = self.bytecode[self.pc]
    self.pc += 1
    pkt_id = self.bytecode[self.pc]
    self.pc += 1
    
    # In a real implementation, we would have channel objects
    # This is a simplified version that just prints the operation
    if is_send:
        print(f"SEND: Channel {chan_id} â† Packet {pkt_id} with value {self.capsules.get(pkt_id)}")
    else:
        print(f"RECV: Channel {chan_id} â†’ Packet {pkt_id}")
        # For testing, just store a dummy value
        self.capsules[pkt_id] = f"received_data_{chan_id}"
# Add these methods to CodeGenerator class

def generate_send_stmt(self, stmt: SendStmt):
    """Generate code for send statement."""
    chan_id = self.symbols.assign_capsule_id(stmt.chan.name)
    pkt_id = self.symbols.assign_capsule_id(stmt.pkt.name)
    self.emit(OPCODES["SEND"], chan_id, pkt_id)

def generate_recv_stmt(self, stmt: RecvStmt):
    """Generate code for receive statement."""
    chan_id = self.symbols.assign_capsule_id(stmt.chan.name)
    pkt_id = self.symbols.assign_capsule_id(stmt.pkt.name)
    self.emit(OPCODES["RECV"], chan_id, pkt_id)

def generate_stamp_stmt(self, stmt: StampStmt):
    """Generate code for stamp statement."""
    capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
    self.generate_expression(stmt.value)  # Push value onto stack
    self.emit(OPCODES["STAMP"], capsule_id)

def generate_error_stmt(self, stmt: ErrorStmt):
    """Generate code for error statement."""
    capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
    self.generate_expression(stmt.code)  # Push error code onto stack
    
    # Push error message
    message_idx = self.constants.add("STRING", stmt.message.value)
    self.emit(OPCODES["PUSHK"])
    self.emit_u16(message_idx)
    
    self.emit(OPCODES["ERROR"], capsule_id)

def generate_spawn_stmt(self, stmt: SpawnStmt):
    """Generate code for spawn statement."""
    func_idx = self.symbols.add_function(stmt.func.name)
    
    # Push arguments onto stack in reverse order
    for arg in reversed(stmt.args):
        if isinstance(arg, Identifier) and arg.is_dollar:
            capsule_id = self.symbols.assign_capsule_id(arg.name)
            self.emit(OPCODES["PUSHCAP"], capsule_id)
        else:
            self.generate_expression(arg)
    
    # Emit SPAWN instruction with function index and arg count
    self.emit(OPCODES["SPAWN"], (func_idx >> 8) & 0xFF, func_idx & 0xFF, len(stmt.args))
    def generate_expire_stmt(self, stmt: ExpireStmt):
        """Generate code for expire statement."""
        capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
        duration_idx = self.constants.add("DURATION", stmt.duration.value)
        
        self.emit(OPCODES["EXPIRE"], capsule_id)
        self.emit_u16(duration_idx)
        def generate_expire_stmt(self, stmt: ExpireStmt):
            """Generate code for expire statement."""
            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
            duration_token = self.constants.add("DURATION", stmt.duration.value)
            self.emit(OPCODES["EXPIRE"], capsule_id)
            self.emit_u16(duration_token)
            def generate_sleep_stmt(self, stmt: SleepStmt):
                """Generate code for sleep statement."""
                """Generate code for sleep statement."""
                duration_idx = self.constants.add("DURATION", stmt.duration.value)
                self.emit(OPCODES["SLEEP"])
                self.emit_u16(duration_idx)
                class Parser:
                    """Parser for the custom language."""
                    def parse_sleep_stmt(self):
                        """Parse #sleep statement."""
                        directive = self.consume(TokenType.HASH_SLEEP, "Expected #sleep")
                        
                        self.consume(TokenType.LPAREN, "Expected '(' after #sleep")
                        duration_token = self.consume(TokenType.DURATION, "Expected duration after #sleep")
                        self.consume(TokenType.RPAREN, "Expected ')' after duration")
                        
                        duration = Literal(
                            line=duration_token.line,
                            column=duration_token.column,
                            kind="DURATION",
                            value=duration_token.value
                        )
                        self.consume(TokenType.SEMICOLON, "Expected ';' after #sleep")
                        return SleepStmt(
                            line=directive.line,
                            column=directive.column,
                            duration=duration
                        )
                    def parse_error_stmt(self):
                        """Parse #error statement."""
                        directive = self.consume(TokenType.HASH_ERROR, "Expected #error")
                        
                        self.consume(TokenType.LPAREN, "Expected '(' after #error")
                        target = self.parse_dollar_identifier()
                        
                        self.consume(TokenType.COMMA, "Expected ',' after target in #error")
                        code = self.parse_value_expr()
                        
                        message = None
                        if self.match(TokenType.COMMA):
                            message_token = self.consume(TokenType.STRING, "Expected error message string")
                            message = Literal(
                                line=message_token.line,
                                column=message_token.column,
                                kind="STRING",
                                value=message_token.value
                            )
                        
                        self.consume(TokenType.RPAREN, "Expected ')' after #error")
                        self.consume(TokenType.SEMICOLON, "Expected ';' after #error")
                        
                        return ErrorStmt(
                            line=directive.line,
                            column=directive.column,
                            target=target,
                            code=code,
                            message=message
                        )
                        return SleepStmt(
                            line=directive.line,
                            column=directive.column,
                            duration=duration
                            )
                    def parse_sleep_stmt(self):
                        """Parse #sleep statement."""
                        directive = self.consume(TokenType.HASH_SLEEP, "Expected #sleep")
                        
                        self.consume(TokenType.LPAREN, "Expected '(' after #sleep")
                        duration_token = self.consume(TokenType.DURATION, "Expected duration after #sleep")
                        self.consume(TokenType.RPAREN, "Expected ')' after duration")
                        
                        duration = Literal(
                            line=duration_token.line,
                            column=duration_token.column,
                            kind="DURATION",
                            value=duration_token.value
                        )
                        self.consume(TokenType.SEMICOLON, "Expected ';' after #sleep")
                        return SleepStmt(
                            line=directive.line,
                            column=directive.column,
                            duration=duration
                            )
                    def parse_longform_init_stmt(self):
                        """Parse long-form initialize statement (init ... with ...)."""
                        directive = self.consume(TokenType.KW_INIT, "Expected 'init'")
                        self.consume(TokenType.LPAREN, "Expected '(' after init")
                        target = self.parse_dollar_identifier()
                        self.consume(TokenType.KW_WITH, "Expected 'with' after init target")
                        self.consume(TokenType.RPAREN, "Expected ')' after init target")
                        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form init")
                        return InitStmt(
                            line=directive.line,
                            column=directive.column,
                            target=target
                        )
                   
    line=directive.line,
    column=directive.column,
    target=target,
    value=value
    
def parse_longform_call_stmt(self):
    def parse_longform_terminate_stmt(self):
                        """Parse long-form terminate statement (terminate ... with ...)."""
                        directive = self.consume(TokenType.KW_TERMINATE, "Expected 'terminate'")
                        self.consume(TokenType.LPAREN, "Expected '(' after terminate")
                        
                        args = []
                        if not self.check(TokenType.RPAREN):
                            args.append(self.parse_value_expr())
                            
                            while self.match(TokenType.COMMA):
                                args.append(self.parse_value_expr())
                        
                        self.consume(TokenType.RPAREN, "Expected ')' after terminate arguments")
                        self.consume(TokenType.SEMICOLON, "Expected ';' after long-form terminate")
                        return TerminateStmt(
                            line=directive.line,
                            column=directive.column,
                            args=args
                        )
                        def parse_longform_terminate_stmt(self):
                            """Parse long-form terminate statement (terminate ... with ...)."""
                            directive = self.consume(TokenType.KW_TERMINATE, "Expected 'terminate'")
                            self.consume(TokenType.LPAREN, "Expected '(' after terminate")
                            
                            args = []
                            if not self.check(TokenType.RPAREN):
                                args.append(self.parse_value_expr())
                                
                                while self.match(TokenType.COMMA):
                                    args.append(self.parse_value_expr())
                            
                            self.consume(TokenType.RPAREN, "Expected ')' after terminate arguments")
                            self.consume(TokenType.SEMICOLON, "Expected ';' after long-form terminate")
                            return TerminateStmt(
                                line=directive.line,
                                column=directive.column,
                                args=args
                            )
                            def parse_longform_terminate_stmt(self):
                                """Parse long-form terminate statement (terminate ... with ...)."""
                                directive = self.consume(TokenType.KW_TERMINATE, "Expected 'terminate'")
                                self.consume(TokenType.LPAREN, "Expected '(' after terminate")
                                
                                args = []
                                if not self.check(TokenType.RPAREN):
                                    args.append(self.parse_value_expr())
                                    
                                    while self.match(TokenType.COMMA):
                                        args.append(self.parse_value_expr())
                                
                                self.consume(TokenType.RPAREN, "Expected ')' after terminate arguments")
                                self.consume(TokenType.SEMICOLON, "Expected ';' after long-form terminate")
                                return TerminateStmt(
                                    line=directive.line,
                                    column=directive.column,
                                    args=args
                                )
                            def parse_expr(self):
                                """Parse an expression."""
                                """Parse an expression."""
                                expr = self.parse_term()
                                while self.match(TokenType.PLUS, TokenType.MINUS):
                                    op = self.previous()
                                    right = self.parse_term()
                                    if op.type == TokenType.PLUS:
                                        op_str = "+"
                                    else:
                                        op_str = "-"
                                        expr = BinaryOp(line=op.line, column=op.column, op=op_str, lhs=expr, rhs=right)
                                        expr = BinaryOp(line=op.line, column=op.column, op=op_str, lhs=expr, rhs=right)
                                        return expr
                                    return expr
                                return expr
                                def parse_term(self):
                                    """Parse a term (factors combined with * or /)."""
                                    term = self.parse_factor()
                                    while self.match(TokenType.STAR, TokenType.SLASH):
                                        op = self.previous()
                                        right = self.parse_factor()
                                        if op.type == TokenType.STAR:
                                            op_str = "*"
                                        else:
                                            op_str = "/"
                                        term = BinaryOp(line=op.line, column=op.column, op=op_str, lhs=term, rhs=right)
                                    return term
                                def parse_factor(self):
                                    """Parse a factor (number, identifier, or parenthesized expression)."""
                                    token = self.consume(TokenType.NUMBER, "Expected number") or \
                                            self.consume(TokenType.IDENTIFIER, "Expected identifier") or \
                                            self.consume(TokenType.LPAREN, "Expected '('")
                                    
                                    if token.type == TokenType.NUMBER:
                                        return Literal(line=token.line, column=token.column, kind="NUMBER", value=token.value)
                                    elif token.type == TokenType.IDENTIFIER:
                                        return Identifier(line=token.line, column=token.column, name=token.value)
                                    elif token.type == TokenType.LPAREN:
                                        self.consume(TokenType.RPAREN, "Expected ')' after expression")
                                        expr = self.parse_expr()
                                        return expr
                                    from typing import Dict, List, Optional, Tuple
                                    from dataclasses import dataclass
                                    from collections import defaultdict
                                    from .ast import Program, Decl, FunctionDecl, LetDecl, Stmt, InitStmt, LoadStmt, CallStmt, ExitStmt, LeaseStmt, SubleaseStmt, ReleaseStmt, SleepStmt, YieldStmt, LabelStmt, GotoStmt, IfStmt, LoopStmt
                                    from .ast import SendStmt, RecvStmt, StampStmt, ErrorStmt, SpawnStmt, ExpireStmt, TerminateStmt
                                    from .ast import Identifier, Literal, BinaryOp
                                    from .ast import Block, Expression, ValueExpr, ValueExprType
                                    @dataclass
                                    class SymbolTable:
                                        """Symbol table for managing scopes and symbols."""
                                        def __init__(self):
                                            self.scopes: List[Dict[str, Dict]] = [{}]
                                            self.functions: Dict[str, int] = {}
                                            self.globals: Dict[str, int] = {}
                                            self.capsules: Dict[str, int] = {}
                                            self.next_label: int = 0
                                            self.label_offsets: Dict[str, int] = {}
                                            def enter_scope(self):
                                                """Enter a new scope."""
                                                self.scopes.append({})
                                                def exit_scope(self):
                                                    """Exit the current scope."""
                                                    if len(self.scopes) > 1:
                                                        self.scopes.pop()
                                                    else:
                                                        raise RuntimeError("Cannot exit global scope")
                                                    def add_function(self, name: str) -> int:
                                                        """Add a function to the symbol table."""
                                                        if name in self.functions:
                                                            raise RuntimeError(f"Function '{name}' already defined")
                                                        func_id = len(self.functions)
                                                        self.functions[name] = func_id
                                                        return func_id
                                                    def add_global(self, name: str) -> int:
                                                        """Add a global variable to the symbol table."""
                                                        if name in self.globals:
                                                            raise RuntimeError(f"Global '{name}' already defined")
                                                        global_id = len(self.globals)
                                                        self.globals[name] = global_id
                                                        return global_id
                                                    def assign_capsule_id(self, name: str) -> int:
                                                        """Assign a capsule ID to a name."""
                                                        if name in self.capsules:
                                                            return self.capsules[name]
                                                        capsule_id = len(self.capsules)
                                                        self.capsules[name] = capsule_id
                                                        return capsule_id
                                                    def set_label_offset(self, label: str, offset: int):
                                                        """Set the offset for a label."""
                                                        if label in self.label_offsets:
                                                            raise RuntimeError(f"Label '{label}' already defined")
                                                        self.label_offsets[label] = offset
                                                        def get_label_offset(self, label: str) -> Optional[int]:
                                                            """Get the offset for a label."""
                                                            """Get the offset for a label."""
                                                            return self.label_offsets.get(label, None)
                                                        from .ast import (
                                                            Program, Decl, FunctionDecl, LetDecl, Stmt, InitStmt,
                                                            LoadStmt, CallStmt, ExitStmt, LeaseStmt, SubleaseStmt,
                                                            ReleaseStmt, SleepStmt, YieldStmt, LabelStmt, GotoStmt,
                                                            IfStmt, LoopStmt, SendStmt, RecvStmt, StampStmt,
                                                            ErrorStmt, SpawnStmt, ExpireStmt, TerminateStmt
                                                        )
                                                        from .vm import OPCODES
                                                        class CodeGenerator:
                                                            """Code generator for the custom language."""
                                                            def __init__(self, symbols: SymbolTable, constants: ConstantPool):
                                                                self.symbols = symbols
                                                                self.constants = constants
                                                                self.bytecode: List[int] = []
                                                                self.fixups: List[Tuple[int, str]] = []
                                                                self.current_offset: int = 0
                                                                def emit(self, opcode: int, *args):
                                                                    """Emit a bytecode instruction."""
                                                                    self.bytecode.append(opcode)
                                                                    for arg in args:
                                                                        self.bytecode.append(arg)
                                                                    self.current_offset += 1 + len(args)
                                                                    def emit_u16(self, value: int):
                                                                        """Emit a 16-bit unsigned integer."""
                                                                        self.bytecode.append((value >> 8) & 0xFF)
                                                                        self.bytecode.append(value & 0xFF)
                                                                        self.current_offset += 2
                                                                        def current_offset(self) -> int:
                                                                            """Get the current bytecode offset."""
                                                                            return self.current_offset
                                                                        def generate_block(self, block: Block):
                                                                            """Generate code for a block of statements."""
                                                                            for stmt in block.statements:
                                                                                self.generate_statement(stmt)
                                                                                if isinstance(stmt, YieldStmt):
                                                                                    # Handle yield by returning control to the VM
                                                                                    return
                                                                                self.emit(OPCODES["END"])
                                                                                def generate_statement(self, stmt: Stmt):
                                                                                    """Generate code for a single statement."""
                                                                                    if isinstance(stmt, InitStmt):
                                                                                        self.generate_init_statement(stmt)
                                                                                    elif isinstance(stmt, LoadStmt):
                                                                                        self.generate_load_statement(stmt)
                                                                                    elif isinstance(stmt, CallStmt):
                                                                                        self.generate_call_statement(stmt)
                                                                                    elif isinstance(stmt, ExitStmt):
                                                                                        self.generate_exit_statement(stmt)
                                                                                    elif isinstance(stmt, LeaseStmt):
                                                                                        self.generate_lease_statement(stmt)
                                                                                    elif isinstance(stmt, SubleaseStmt):
                                                                                        self.generate_sublease_statement(stmt)
                                                                                    elif isinstance(stmt, ReleaseStmt):
                                                                                        self.generate_release_statement(stmt)
                                                                                    elif isinstance(stmt, SleepStmt):
                                                                                        self.generate_sleep_statement(stmt)
                                                                                    elif isinstance(stmt, YieldStmt):
                                                                                        self.emit(OPCODES["YIELD"])
                                                                                    elif isinstance(stmt, LabelStmt):
                                                                                        self.generate_label_statement(stmt)
                                                                                    elif isinstance(stmt, GotoStmt):
                                                                                        self.generate_goto_statement(stmt)
                                                                                    elif isinstance(stmt, IfStmt):
                                                                                        self.generate_if_statement(stmt)
                                                                                    elif isinstance(stmt, LoopStmt):
                                                                                        self.generate_loop_statement(stmt)
                                                                                    elif isinstance(stmt, SendStmt):
                                                                                        self.generate_send_stmt(stmt)
                                                                                    elif isinstance(stmt, RecvStmt):
                                                                                        self.generate_recv_stmt(stmt)
                                                                                    elif isinstance(stmt, StampStmt):
                                                                                        self.generate_stamp_stmt(stmt)
                                                                                    elif isinstance(stmt, ErrorStmt):
                                                                                        self.generate_error_stmt(stmt)
                                                                                    elif isinstance(stmt, SpawnStmt):
                                                                                        self.generate_spawn_stmt(stmt)
                                                                                    elif isinstance(stmt, ExpireStmt):
                                                                                        self.generate_expire_stmt(stmt)
                                                                                    elif isinstance(stmt, TerminateStmt):
                                                                                        self.generate_terminate_stmt(stmt)
                                                                                        def run(self):
                                                                                            """Run the generated bytecode."""
                                                                                            self.pc = 0
                                                                                            while self.pc < len(self.bytecode):
                                                                                                opcode = self.bytecode[self.pc]
                                                                                                self.pc += 1
                                                                                                if opcode == OPCODES["RENDER"]:
                                                                                                    self.handle_render()
                                                                                                elif opcode == OPCODES["INPUT"]:
                                                                                                    self.handle_input()
                                                                                                elif opcode == OPCODES["SEND"]:
                                                                                                    self.handle_send_recv(is_send=True)
                                                                                                elif opcode == OPCODES["RECV"]:
                                                                                                    self.handle_send_recv(is_send=False)
                                                                                                else:
                                                                                                    raise RuntimeError(f"Unknown opcode {opcode}")
                                                                                                def generate_terminate_stmt(self, stmt: TerminateStmt):
                                                                                                    """Generate code for terminate statement."""
                                                                                                    capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
                                                                                                    """Generate code for terminate statement."""
                                                                                                    self.emit(OPCODES["TERMINATE"], capsule_id)
                                                                                                    def generate_spawn_stmt(self, stmt: SpawnStmt, tmt: Optional[int] = None):
                                                                                                        func_idx: any 
    """Generate code for spawn statement."""
func_idx = self.symbols.add_function(stmt.function.name)
if tmt is not None:
                        self.emit(OPCODES["SPAWN_TMT"], (func_idx >> 8) & 0xFF, func_idx & 0xFF, len(stmt.args), tmt)
                        trueelse: true
                        self.emit(OPCODES["SPAWN"], (func_idx >> 8) & 0xFF, func_idx & 0xFF, len(stmt.args))
                        for arg in stmt.args:
                            arg_idx = self.constants.add("ARG", arg.value)
                            self.emit_u16(arg_idx)
                            capsule_id = self.symbols.assign_capsule_id(stmt.target.name)
                            self.emit(OPCODES["SPAWN"], capsule_id)
                            self.emit_u16(func_idx)
                            for arg in stmt.args:
                                arg_idx = self.constants.add("ARG", arg.value)
                                self.emit_u16(arg_idx)
                                for arg in stmt.args:
                                    arg_idx = self.constants.add("ARG", arg.value)
                                    self.emit_u16(arg_idx)
                                    self.emit(OPCODES["SPAWN"], func_idx)
                                    self.emit(OPCODES["SPAWN"], func_idx)
                                    self.emit_u16(arg_idx)
                                    
